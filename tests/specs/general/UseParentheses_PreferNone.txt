~~ useParentheses: preferNone, useBraces: preferNone ~~
== should remove multi-line parentheses in expression statement without comment ==
if (a)
  (f
    ());

[expect]
if (a)
    f();

== should keep multi-line parentheses in expression statement with comment ==
if (a)
  (f //
    ());

[expect]
if (a) {
    f //
    ();
}

== should remove multi-line parentheses in return without braces ==
if (a)
  return (f
    ());

[expect]
if (a)
    return f();

== should keep multi-line parentheses in return with comment ==
if (a)
  return (f //
    ());

[expect]
if (a) {
    return f //
    ();
}

== should remove multi-line parentheses in return with function call on next line ==
if (a)
  return (f
(veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongIdentifierName1234567890123456789012345678901234567890));

[expect]
if (a) {
    return f(
        veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongIdentifierName1234567890123456789012345678901234567890,
    );
}

== should remove multi-line parentheses around long variable in return ==
return (
  veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongIdentifierName1234567890123456789012345678901234567890);

[expect]
return veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongIdentifierName1234567890123456789012345678901234567890;

== should remove multi-line parentheses in throw without braces ==
if (a)
  throw (f
    ());

[expect]
if (a)
    throw f();

== should keep multi-line parentheses in throw with comment ==
if (a)
  throw (f //
    ());

[expect]
if (a) {
    throw f //
    ();
}

== should remove multi-line parentheses in yield without braces ==
function* gen() {
  if (a)
    yield (f
      ());
}

[expect]
function* gen() {
    if (a)
        yield f();
}

== should keep multi-line parentheses in yield with comment ==
function* gen() {
  if (a)
    yield (f //
      ());
}

[expect]
function* gen() {
    if (a) {
        yield f //
        ();
    }
}

== should keep multi-line parentheses in call argument with comment ==
foo((arg //
));

[expect]
foo(
    (
        arg //
    ),
);

== should remove multi-line parentheses in call argument without comment ==
foo((arg
));

[expect]
foo(arg);

== should keep multi-line parentheses in array element with comment ==
[(item //
)];

[expect]
[
    (
        item //
    ),
];

== should remove multi-line parentheses in array element without comment ==
[(item
)];

[expect]
[item];

== should keep multi-line parentheses around optional chain object with comment ==
(f //
)?.prop;

[expect]
(
    f //
)?.prop;

== should remove multi-line parentheses around optional chain object without comment ==
(f
)?.prop;

[expect]
f?.prop;

== should keep multi-line parentheses with comment before optional chain member access ==
(f //
?.prop);

[expect]
f //
    ?.prop;

== should remove multi-line parentheses around optional chain member access without comment ==
(f
?.prop);

[expect]
f
    ?.prop;

== should keep multi-line parentheses around member access object with comment ==
(f //
).prop;

[expect]
(
    f //
).prop;

== should remove multi-line parentheses around member access object without comment ==
(f
).prop;

[expect]
f.prop;

== should keep multi-line parentheses with comment before member access ==
(f //
.prop);

[expect]
f //
    .prop;

== should remove multi-line parentheses around member access without comment ==
(f
.prop);

[expect]
f
    .prop;

== should keep multi-line parentheses around call callee with comment ==
(f //
)();

[expect]
(
    f //
)();

== should remove multi-line parentheses around call callee without comment ==
(f
)();

[expect]
f();

== should keep multi-line parentheses with comment before call ==
(f //
());

[expect]
f //
();

== should remove multi-line parentheses around call without comment ==
(f
());

[expect]
f();

== should keep multi-line parentheses around optional call callee with comment ==
(f //
)?.();

[expect]
(
    f //
)?.();

== should remove multi-line parentheses around optional call callee without comment ==
(f
)?.();

[expect]
f?.();

== should keep multi-line parentheses with comment before optional chain ==
(f //
?.());

[expect]
f //
?.();

== should remove multi-line parentheses around optional chain call without comment ==
(f
?.());

[expect]
f?.();

== TEST: single line array access should remove parens ==
(a[2]);

[expect]
a[2];

== should keep multi-line parentheses around call expression ==
(f //
());

[expect]
f //
();

== should keep multi-line parentheses around function callee ==
(f //
)();

[expect]
(
    f //
)();

== should remove parentheses inside call arguments ==
f((1 + 2));

[expect]
f(1 + 2);

== should remove parentheses inside return statement ==
function test() {
    return (value);
}

[expect]
function test() {
    return value;
}

== should keep parentheses when they affect operator precedence ==
const result = (a + b) * c;

[expect]
const result = (a + b) * c;

== should retain parentheses that enforce grouping ==
const ambiguous = a / (b * c);

[expect]
const ambiguous = a / (b * c);

== should remove parentheses that do not affect precedence ==
const precedenceOk = (a * b) + c;

[expect]
const precedenceOk = a * b + c;

== should remove parentheses in ternary branches ==
const value = condition ? (left) : (right);

[expect]
const value = condition ? left : right;

== should remove parentheses inside array elements ==
const items = [(value), ((other))];

[expect]
const items = [value, other];

== should remove parentheses in array destructuring pattern ==
const [value = (await load())] = source;

[expect]
const [value = await load()] = source;

== should remove parentheses inside object properties ==
const obj = {
    prop: (value),
    nested: ((other)),
};

[expect]
const obj = {
    prop: value,
    nested: other,
};

== should keep parentheses around object literal arrow body ==
const arrow = () => ({ value: 1 });

[expect]
const arrow = () => ({ value: 1 });

== should remove parentheses inside template expression ==
const message = `hello ${ (name) }`;

[expect]
const message = `hello ${name}`;

== should remove parentheses around optional chaining ==
const maybe = (obj?.prop);

[expect]
const maybe = obj?.prop;

== should retain parentheses around optional chaining when combined with exponentiation ==
const complex = (obj?.value) ** 2;

[expect]
const complex = (obj?.value) ** 2;

== should keep parentheses around function expression callees ==
const iifeResult = (function () {})();

[expect]
const iifeResult = (function() {})();

== should keep parentheses around optional chained function expression callees ==
const optionalIife = (function () {})?.();

[expect]
const optionalIife = (function() {})?.();

== should keep parentheses around optional chained arrow callees ==
const optionalArrowIife = (() => {})?.();

[expect]
const optionalArrowIife = (() => {})?.();

== should remove redundant parens in nested optional arrow calls ==
const nestedOptionalArrow = ((() => {})?.())?.();

[expect]
const nestedOptionalArrow = (() => {})?.()?.();

== should keep parentheses around optional chained class expression callees ==
const optionalClassIife = (class {})?.();

[expect]
const optionalClassIife = (class {})?.();

== should keep parentheses around optional chained class expression property access ==
const optionalClassProp = (class { constructor() { this.prop = 1; } })?.prop;

[expect]
const optionalClassProp = (class {
    constructor() {
        this.prop = 1;
    }
})?.prop;

== should keep parentheses around optional chained function expression property access ==
const optionalFuncProp = (function () {})?.prop;

[expect]
const optionalFuncProp = (function() {})?.prop;

== should keep parentheses around optional chained arrow function property access ==
const optionalArrowProp = (() => {})?.prop;

[expect]
const optionalArrowProp = (() => {})?.prop;

== should keep parentheses around multi-line function expression property access ==
const functionPropMultiline = (function () {}
    ).prop;

[expect]
const functionPropMultiline = (function() {}).prop;

== should keep parentheses around multi-line class expression property access ==
const classPropMultiline = (class {}
    ).prop;

[expect]
const classPropMultiline = (class {}).prop;

== should keep parentheses around multi-line arrow function property access ==
const arrowPropMultiline = (() => {}
    ).prop;

[expect]
const arrowPropMultiline = (() => {}).prop;

== should keep parentheses around multi-line optional chained function property access ==
const optionalFunctionPropMultiline = (function () {}
    )?.prop;

[expect]
const optionalFunctionPropMultiline = (function() {})?.prop;

== should keep parentheses around multi-line optional chained function property access with comment ==
const optionalFunctionPropMultilineComment = (function () {}
    )?.prop; // comment

[expect]
const optionalFunctionPropMultilineComment = (function() {})?.prop; // comment

== should keep parentheses around multi-line optional chained arrow call ==
const optionalArrowCallMultiline = (() => {}
    )?.();

[expect]
const optionalArrowCallMultiline = (() => {})?.();

== should keep parentheses around multi-line optional chained function call ==
const optionalFunctionCallMultiline = (function () {}
    )?.();

[expect]
const optionalFunctionCallMultiline = (function() {})?.();

== should remove redundant parens around optional chained new expression access ==
const optionalNewProp = (new Foo())?.prop;

[expect]
const optionalNewProp = new Foo()?.prop;

== should keep parentheses around multi-line optional chained new expression access ==
const optionalNewPropMultiline = (new Foo
    ())?.prop;

[expect]
const optionalNewPropMultiline = new Foo()?.prop;

== should remove parentheses around nullish coalescing inside assignments ==
const fallback = (primary ?? secondary);

[expect]
const fallback = primary ?? secondary;

== should remove parentheses around await inside expressions ==
async function load() {
    const data = (await fetchData());
}

[expect]
async function load() {
    const data = await fetchData();
}

== should keep parentheses around awaited call when accessing members ==
async function useData() {
    return (await loadData()).map(item => item);
}

[expect]
async function useData() {
    return (await loadData()).map(item => item);
}

== should remove parentheses around yield expression ==
function* gen() {
    yield (value);
}

[expect]
function* gen() {
    yield value;
}

== should remove parentheses around yield used in array ==
function* collect() {
    const collected = [ (yield value) ];
}

[expect]
function* collect() {
    const collected = [yield value];
}

== should keep parentheses around yield when accessing members ==
function* project() {
    const result = (yield getValue()).prop;
}

[expect]
function* project() {
    const result = (yield getValue()).prop;
}

== should keep parentheses around multi-line yield expression ==
function* yieldMultiline() {
    yield (getGenerator
        ());
}

[expect]
function* yieldMultiline() {
    yield getGenerator();
}

== should keep parentheses around multi-line yield optional call ==
function* yieldOptionalMultiline() {
    return (yield getFactory
        ())?.();
}

[expect]
function* yieldOptionalMultiline() {
    return (yield getFactory())?.();
}

== should keep parentheses around multi-line yield property access ==
function* yieldPropertyMultiline() {
    return (yield getFactory
        ()).value;
}

[expect]
function* yieldPropertyMultiline() {
    return (yield getFactory()).value;
}

== should remove parentheses around throw expression ==
throw (error);

[expect]
throw error;

== should keep parentheses around multi-line throw expression ==
function throwMultiline() {
    throw (createError
        ());
}

[expect]
function throwMultiline() {
    throw createError();
}

== should keep parentheses around multi-line await expression in throw ==
async function throwAwaitMultiline() {
    throw (await createAsyncError
        ());
}

[expect]
async function throwAwaitMultiline() {
    throw await createAsyncError();
}

== should keep parentheses around multi-line throw optional call ==
function throwOptionalMultiline() {
    throw (getFactory
        ())?.();
}

[expect]
function throwOptionalMultiline() {
    throw getFactory()?.();
}

== should keep parentheses around multi-line throw property access ==
function throwPropertyMultiline() {
    throw (createError
        ()).code;
}

[expect]
function throwPropertyMultiline() {
    throw createError().code;
}

== should retain parentheses around throw in IIFE ==
const result = condition ? value : (() => { throw error; })();

[expect]
const result = condition ? value : (() => {
    throw error;
})();

== should remove parentheses around export default expression ==
export default (component);

[expect]
export default component;

== should retain parentheses around export default when template literal ==
export default (`value`);

[expect]
export default (`value`);

== should remove parentheses in if condition ==
if ((condition)) {
    doSomething();
}

[expect]
if (condition)
    doSomething();

== should keep parentheses around multi-line await in if condition ==
async function ifAwaitMultiline() {
    if ((await shouldProceed
        ())) {
        doSomething();
    }
}

[expect]
async function ifAwaitMultiline() {
    if (await shouldProceed())
        doSomething();
}

== should remove parentheses in while condition ==
while ((ready)) {
    run();
}

[expect]
while (ready)
    run();

== should remove parentheses in do while condition ==
do {
    work();
} while ((shouldContinue));

[expect]
do {
    work();
} while (shouldContinue);

== should keep parentheses around multi-line await in while condition ==
async function whileAwaitMultiline() {
    while ((await shouldContinue
        ())) {
        run();
    }
}

[expect]
async function whileAwaitMultiline() {
    while (await shouldContinue())
        run();
}

== should remove parentheses in for-of iterable ==
for (const item of (collection)) {
    consume(item);
}

[expect]
for (const item of collection)
    consume(item);

== should keep parentheses around multi-line await in for-of iterable ==
async function forOfAwaitMultiline() {
    for (const item of (await loadItems
        ())) {
        consume(item);
    }
}

[expect]
async function forOfAwaitMultiline() {
    for (const item of await loadItems())
        consume(item);
}

== should remove parentheses in for head ==
for (let i = (0); i < (max); i++) {
    step(i);
}

[expect]
for (let i = 0; i < max; i++)
    step(i);

== should remove parentheses in switch discriminant and cases ==
switch ((value)) {
case (1):
    break;
}

[expect]
switch (value) {
    case 1:
        break;
}

== should remove parentheses around unary operations ==
const increment = (++(value));

[expect]
const increment = ++value;

== should remove parentheses around typeof in binary expressions ==
const typeCheck = (typeof value) + " suffix";

[expect]
const typeCheck = typeof value + " suffix";

== should keep parentheses around delete when followed by member access ==
const deleteResult = (delete obj.prop).toString();

[expect]
const deleteResult = (delete obj.prop).toString();

== should keep parentheses around typeof when accessing members ==
const typeInfo = (typeof value).toUpperCase();

[expect]
const typeInfo = (typeof value).toUpperCase();

== should keep parentheses around void when accessing members ==
const voidInfo = (void 0).toString();

[expect]
const voidInfo = (void 0).toString();

== should remove parentheses in default parameter initializers ==
function configure(option = (defaultValue)) {}

[expect]
function configure(option = defaultValue) {}

== should remove parentheses inside logical expressions ==
const combined = (a && b) || (c && d);

[expect]
const combined = a && b || c && d;

== should retain parentheses in logical expression when required ==
const precedence = a && (b || c);

[expect]
const precedence = a && (b || c);

== should remove parentheses around new expression ==
const instance = (new Foo());

[expect]
const instance = new Foo();

== should retain parentheses around new with call when needed ==
const construct = (new Foo())();

[expect]
const construct = (new Foo())();

== should remove parentheses around typeof/void/delete ==
const info = {
    type: typeof (value),
    cleared: void (0),
    removed: delete (obj.prop),
};

[expect]
const info = {
    type: typeof value,
    cleared: void 0,
    removed: delete obj.prop,
};

== should remove parentheses around tagged template expressions ==
const tagged = tag((value));

[expect]
const tagged = tag(value);

== should remove parentheses inside class field initializer ==
class Example {
    value = (initial);
}

[expect]
class Example {
    value = initial;
}

== should remove parentheses in array destructuring defaults ==
const [first = (fallback)] = source;

[expect]
const [first = fallback] = source;

== should remove parentheses in object destructuring defaults ==
const { value = (fallback) } = source;

[expect]
const { value = fallback } = source;

== should remove parentheses around dynamic import specifier ==
async function load() {
    return import((moduleName));
}

[expect]
async function load() {
    return import(moduleName);
}

== should retain parentheses around dynamic import with assertions ==
async function load() {
    return import(moduleName, { with: (options) });
}

[expect]
async function load() {
    return import(moduleName, { with: options });
}

== should remove parentheses around class heritage ==
class Derived extends (Base) {}

[expect]
class Derived extends Base {}

== should remove parentheses in super call ==
class Child extends Base {
    constructor() {
        super((arg));
    }
}

[expect]
class Child extends Base {
    constructor() {
        super(arg);
    }
}

== should remove parentheses around yield star expression ==
function* forward() {
    yield* (iterable);
}

[expect]
function* forward() {
    yield* iterable;
}

== should keep parentheses around multi-line yield star expression ==
function* forwardMultiline() {
    yield* (getIterable
        ());
}

[expect]
function* forwardMultiline() {
    yield* getIterable();
}

== should keep parentheses around sequence expressions ==
doSomething((a, b));

[expect]
doSomething((a, b));

== should remove parentheses around call expression results ==
const resultCall = (compute()) + 1;

[expect]
const resultCall = compute() + 1;

== should remove parentheses around expressions in for loop headers ==
for (let i = (0); i < (max); i++) {}

[expect]
for (let i = 0; i < max; i++) {}

== should retain parentheses when mixing nullish coalescing with logical OR ==
const fallbackOr = (x ?? y) || z;

[expect]
const fallbackOr = (x ?? y) || z;

== should retain parentheses when mixing nullish coalescing with logical AND ==
const fallbackAnd = (x ?? y) && z;

[expect]
const fallbackAnd = (x ?? y) && z;

== should retain parentheses when mixing logical OR with nullish coalescing ==
const orWithNull = x || (y ?? z);

[expect]
const orWithNull = x || (y ?? z);

== should retain parentheses when mixing logical AND with nullish coalescing ==
const andWithNull = x && (y ?? z);

[expect]
const andWithNull = x && (y ?? z);

== should remove parentheses around delete in logical expressions ==
const deleteCheck = (delete obj.prop) && other;

[expect]
const deleteCheck = delete obj.prop && other;

== should remove parentheses around typeof in binary expressions ==
const typeCheck = (typeof value) + " suffix";

[expect]
const typeCheck = typeof value + " suffix";

== should remove parentheses around void in logical expressions ==
const voidCheck = (void 0) || fallback;

[expect]
const voidCheck = void 0 || fallback;

== should keep parentheses around await in binary expressions ==
async function asyncBinary() {
    const result = (await fetch()) + 1;
}

[expect]
async function asyncBinary() {
    const result = (await fetch()) + 1;
}

== should remove redundant parentheses around await when returned ==
async function returnAwait(condition) {
    return (await resolveValue(condition));
}

[expect]
async function returnAwait(condition) {
    return await resolveValue(condition);
}

== should keep parentheses around multi-line return call ==
function returnMultilineCall() {
    return (getFactory
        ());
}

[expect]
function returnMultilineCall() {
    return getFactory();
}

== should keep parentheses around multi-line return call with comment ==
function returnMultilineCallWithComment() {
    return (createFactory // comment
        ());
}

[expect]
function returnMultilineCallWithComment() {
    return createFactory // comment
    ();
}

== should keep parentheses around multi-line throw call with comment ==
function throwMultilineWithComment() {
    throw (createError // comment
        ());
}

[expect]
function throwMultilineWithComment() {
    throw createError // comment
    ();
}

== should keep parentheses around multi-line await expression ==
async function awaitMultiline() {
    return (await loadData
        ()).map(item => item);
}

[expect]
async function awaitMultiline() {
    return (await loadData()).map(item => item);
}

== should keep parentheses around multi-line await optional call ==
async function awaitOptionalMultiline() {
    return (await loadFactory
        ())?.();
}

[expect]
async function awaitOptionalMultiline() {
    return (await loadFactory())?.();
}

== should keep parentheses around multi-line await binary expression ==
async function awaitBinaryMultiline() {
    const total = (await computeValue
        ()) + 1;
    return total;
}

[expect]
async function awaitBinaryMultiline() {
    const total = (await computeValue()) + 1;
    return total;
}

== should keep parentheses around multi-line return property access ==
function returnPropertyMultiline() {
    return (getObject
        ()).value;
}

[expect]
function returnPropertyMultiline() {
    return getObject().value;
}

== should keep parentheses around multi-line return optional call ==
function returnOptionalMultiline() {
    return (getCallback
        ())?.();
}

[expect]
function returnOptionalMultiline() {
    return getCallback()?.();
}

== should keep parentheses around multi-line return property access with comment ==
function returnPropertyMultilineComment() {
    return (getObject // comment
        ()).value;
}

[expect]
function returnPropertyMultilineComment() {
    return getObject // comment
    ().value;
}

== should remove redundant parentheses around await in ternary expressions ==
async function asyncTernary() {
    const value = condition ? (await foo()) : bar;
}

[expect]
async function asyncTernary() {
    const value = condition ? await foo() : bar;
}

== should retain parentheses around yield in binary expressions ==
function* yieldBinary() {
    const result = (yield value) + 1;
}

[expect]
function* yieldBinary() {
    const result = (yield value) + 1;
}

== should keep parentheses around multi-line yield binary expression ==
function* yieldBinaryMultiline() {
    const result = (yield computeValue
        ()) + 1;
    return result;
}

[expect]
function* yieldBinaryMultiline() {
    const result = (yield computeValue()) + 1;
    return result;
}

== should remove redundant parens around member access on await in ternary condition ==
async function ternaryAccess(cond) {
    return ((await fetchData()).value) ? (await fetchData()).value : defaultValue;
}

[expect]
async function ternaryAccess(cond) {
    return (await fetchData()).value ? (await fetchData()).value : defaultValue;
}

== should keep parentheses around object literal (disambiguation required) ==
({
    prop: value
});

[expect]
({
    prop: value,
});

== should keep parentheses around function expression (disambiguation required) ==
(function test() {
    return 1;
});

[expect]
(function test() {
    return 1;
});

== should NOT add parentheses around arrow function ==
() => 42;

[expect]
() => 42;

== should remove parentheses around arrow function ==
(() => 42);

[expect]
() => 42;

== should NOT add parentheses around simple identifier (not supported) ==
someVariable;

[expect]
someVariable;

== should NOT add parentheses around call expression (not supported) ==
someFunction();

[expect]
someFunction();

== should remove parentheses around call expression ==
(someFunction());

[expect]
someFunction();

== should NOT add parentheses around member expression (not supported) ==
obj.prop;

[expect]
obj.prop;

== should NOT add parentheses around array literal (not supported) ==
[1, 2, 3];

[expect]
[1, 2, 3];

== should NOT add parentheses around template literal (not supported) ==
`hello world`;

[expect]
`hello world`;

== should NOT add parentheses around binary expression (not supported) ==
a + b;

[expect]
a + b;

== should remove parentheses around binary expression ==
(a + b);

[expect]
a + b;

== should remove redundant outer parens from nested binary expressions ==
((a || b) && c);

[expect]
(a || b) && c;

== should remove redundant outer parens from simple expression ==
(value);

[expect]
value;

== should keep parentheses that affect operator precedence ==
((a + b) * c);

[expect]
(a + b) * c;

== should keep parentheses around arrow function used as callee ==
(() => 42)();

[expect]
(() => 42)();

== should keep parentheses around arrow function used in optional chain ==
(() => 42)?.prop;

[expect]
(() => 42)?.prop;

== should keep parentheses around arrow function with type assertion ==
(() => 42) as NumberFunction;

[expect]
(() => 42) as NumberFunction;

== should remove parentheses around await expression ==
(await value());

[expect]
await value();

== should remove parentheses around unary expression ==
(+value);

[expect]
+value;

== should remove parentheses around prefix increment ==
+(value);

[expect]
+value;

== should remove parentheses around new expression ==
(new Foo());

[expect]
new Foo();

== should remove parentheses around optional chain expression ==
(obj?.prop);

[expect]
obj?.prop;

== should remove parentheses around nullish coalescing expression ==
(a ?? b);

[expect]
a ?? b;

== should keep parentheses around object literal with as assertion ==
({}) as Foo;

[expect]
({}) as Foo;

== should keep parentheses around object literal with satisfies assertion ==
({}) satisfies Foo;

[expect]
({}) satisfies Foo;

== should keep parentheses around object literal with as const assertion ==
({}) as const;

[expect]
({}) as const;

== should NOT add parentheses around object literal with type assertion ==
<Foo>{};

[expect]
<Foo> {};

== should keep parentheses around object literal with non-null assertion ==
({})!;

[expect]
({})!;

== should keep parentheses around object literal with multiple assertions ==
({}) as Foo as Bar;

[expect]
({}) as Foo as Bar;

== should keep parentheses around object literal with as assertion inside while loop ==
while (true) {
    ({} as X);
}

[expect]
while (true)
    ({} as X);

== should keep parentheses around function expression with as assertion ==
(function() {}) as Foo;

[expect]
(function() {}) as Foo;

== should keep parentheses around function expression with satisfies assertion ==
(function() {}) satisfies Foo;

[expect]
(function() {}) satisfies Foo;

== should keep parentheses around function expression with as const assertion ==
(function() {}) as const;

[expect]
(function() {}) as const;

== should keep parentheses around function expression with non-null assertion ==
(function() {})!;

[expect]
(function() {})!;

== should keep parentheses around function expression with multiple assertions ==
(function() {}) as Foo as Bar;

[expect]
(function() {}) as Foo as Bar;

== should NOT add parentheses around arrow function with as assertion ==
(() => 42) as Foo;

[expect]
(() => 42) as Foo;

== should NOT add parentheses around call expression with as assertion ==
foo() as Bar;

[expect]
foo() as Bar;

== should keep parentheses around nested object literal with assertions ==
({prop: {}}) as Foo;

[expect]
({ prop: {} }) as Foo;

== should keep parentheses around object literal used as member expression base ==
({}).foo;

[expect]
({}).foo;

== should keep parentheses around object literal used as call expression callee ==
({})();

[expect]
({})();

== should keep parentheses around object literal used as optional chain base ==
({})?.prop;

[expect]
({})?.prop;

== should keep parentheses around function expression used as member expression base ==
(function() {}).foo;

[expect]
(function() {}).foo;

== should keep parentheses around function expression used as call expression callee ==
(function() {})();

[expect]
(function() {})();

== should keep parentheses around function expression used as optional chain base ==
(function() {})?.prop;

[expect]
(function() {})?.prop;

== should keep parentheses with mixed assertion wrappers on object literal ==
({})! as Foo;

[expect]
({})! as Foo;

== should keep parentheses with mixed assertion wrappers on function expression ==
(function() {})! as Foo;

[expect]
(function() {})! as Foo;

== should keep parentheses with chained mixed assertions on object literal ==
({}) as Foo satisfies Bar;

[expect]
({}) as Foo satisfies Bar;

== should keep parentheses with chained mixed assertions on function expression ==
(function() {}) as Foo satisfies Bar;

[expect]
(function() {}) as Foo satisfies Bar;

== should remove redundant outer parens from nested assertion chains on object literal ==
(({} as X) as Y);

[expect]
({} as X) as Y;

== should remove redundant outer parens from nested assertion chains on function expression ==
((function() {}) as X) as Y;

[expect]
(function() {}) as X as Y;

== should remove redundant outer parens from nested assertion chains on class expression ==
((class {}) as X) as Y;

[expect]
(class {}) as X as Y;

== should keep parentheses around sequence expression ==
(a, b);

[expect]
(a, b);

== should keep parentheses around anonymous class expression ==
(class {});

[expect]
(class {});

== should keep parentheses around named class expression ==
(class Foo {});

[expect]
(class Foo {});

== should keep parentheses around class expression with as assertion ==
(class {}) as Foo;

[expect]
(class {}) as Foo;

== should keep parentheses around class expression with satisfies assertion ==
(class {}) satisfies Foo;

[expect]
(class {}) satisfies Foo;

== should keep parentheses around class expression with as const assertion ==
(class {}) as const;

[expect]
(class {}) as const;

== should keep parentheses around class expression with non-null assertion ==
(class {})!;

[expect]
(class {})!;

== should keep parentheses around class expression with multiple assertions ==
(class {}) as Foo as Bar;

[expect]
(class {}) as Foo as Bar;

== should keep parentheses with mixed assertion wrappers on class expression ==
(class {})! as Foo;

[expect]
(class {})! as Foo;

== should keep parentheses around class expression with chained mixed assertions ==
(class {}) as Foo satisfies Bar;

[expect]
(class {}) as Foo satisfies Bar;

== should keep parentheses around class expression used as member expression base ==
(class {}).foo;

[expect]
(class {}).foo;

== should keep parentheses around class expression used as call expression callee ==
(class {})();

[expect]
(class {})();

== should keep parentheses around class expression used as optional chain base ==
(class {})?.prop;

[expect]
(class {})?.prop;
